<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Performance optimisation in pynbody &mdash; pynbody 0.18-alpha documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.18-alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="pynbody 0.18-alpha documentation" href="../index.html" />
    <link rel="up" title="Pynbody Tutorials" href="tutorials.html" />
    <link rel="next" title="Configuring pynbody" href="configuration.html" />
    <link rel="prev" title="Batch-processing Snapshots with Pynbody" href="processing.html" />
 
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38063425-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="configuration.html" title="Configuring pynbody"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="processing.html" title="Batch-processing Snapshots with Pynbody"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">pynbody 0.18-alpha documentation</a> &raquo;</li>
          <li><a href="tutorials.html" accesskey="U">Pynbody Tutorials</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="performance-optimisation-in-pynbody">
<span id="performance"></span><h1>Performance optimisation in pynbody<a class="headerlink" href="#performance-optimisation-in-pynbody" title="Permalink to this headline">¶</a></h1>
<p><cite>Pynbody</cite> is built on top of <cite>numpy</cite>, which means that learning how to optimize <cite>numpy</cite>
array manipulations is the most important route to writing efficient code; see <a class="reference external" href="http://scipy-lectures.github.com/advanced/optimizing/index.html">http://scipy-lectures.github.com/advanced/optimizing/index.html</a>
for an introduction.</p>
<p>However there are a few issues which are specific to <cite>pynbody</cite>. By far the most important of these
that we have come across is the overheads incurred by using <a href="#id1"><span class="problematic" id="id2">`</span></a>SubSnap`s
which are explained
below.</p>
<div class="section" id="overheads-of-subsnaps">
<h2>Overheads of SubSnaps<a class="headerlink" href="#overheads-of-subsnaps" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-template-for-performance-critical-code">
<h3>A template for performance-critical code<a class="headerlink" href="#a-template-for-performance-critical-code" title="Permalink to this headline">¶</a></h3>
<p>To cut a long story short, if your routine does a lot of array access on an object which might
be a <cite>SubSnap</cite> of a certain flavour (explained further below), you will find that wrapping your
code as follows speeds it up.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_expensive_operation</span><span class="p">(</span><span class="n">sim_or_subsim</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">with</span> <span class="n">sim_or_subsim</span><span class="o">.</span><span class="n">immediate_mode</span> <span class="p">:</span>
        <span class="n">mass_array</span> <span class="o">=</span> <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
        <span class="n">other_array</span> <span class="o">=</span> <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;other&#39;</span><span class="p">]</span>
        <span class="c"># ... get other arrays required...</span>

        <span class="c">#</span>
        <span class="c"># perform multiple operations on arrays</span>
        <span class="c">#</span>

        <span class="c"># At end, copy back results if the arrays have</span>
        <span class="c"># changed</span>
        <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;other&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_array</span>
</pre></div>
</div>
<p>The remainder of this document unpacks what this does and why it should be necessary.</p>
</div>
<div class="section" id="what-is-a-subsnap-really">
<h3>What is a SubSnap, really?<a class="headerlink" href="#what-is-a-subsnap-really" title="Permalink to this headline">¶</a></h3>
<p>When you construct a <cite>SubSnap</cite>, the framework records which particles of the underlying
<cite>SimSnap</cite> are included and which are not. Thereafter, if you access an array from the <cite>SubSnap</cite>,
it is constructed in one of two ways.</p>
<blockquote>
<div><ul class="simple">
<li>If the set of particles indexed by the <cite>SubSnap</cite> is expressable a slice, the
arrays constructed are still <cite>numpy</cite> arrays.  This will be the case if you explicitly
slice the simulation (e.g. <tt class="docutils literal"><span class="pre">f[2:100:3]</span></tt>), or if you ask for a specific particle family (e.g. <tt class="docutils literal"><span class="pre">f.dm</span></tt>).</li>
<li>If the set of particles is not expressable in this way, the arrays constructed are
emulating <cite>numpy</cite> arrays and this can become expensive (see below). This will
be the cae if you ask for a list of particles (e.g. <tt class="docutils literal"><span class="pre">f[[2,10,15,22]]</span></tt>) use a <cite>numpy</cite>-like
indexing trick (e.g. <tt class="docutils literal"><span class="pre">f[f['x']&gt;10]</span></tt> or <tt class="docutils literal"><span class="pre">f[numpy.where(f['x']&gt;10)]</span></tt>) or use a
<a class="reference internal" href="../convenience.html#module-pynbody.filt" title="pynbody.filt"><tt class="xref py py-mod docutils literal"><span class="pre">filter</span></tt></a>.</li>
</ul>
</div></blockquote>
<p>In the first case, the optimization is unchanged from the raw <cite>SimSnap</cite> case.
In the second case, the situation is different.
To understand how and why, we
need to look at the difference between an indexed and a sliced <cite>numpy</cite> array.</p>
</div>
<div class="section" id="numpy-s-behaviour">
<h3>Numpy&#8217;s behaviour<a class="headerlink" href="#numpy-s-behaviour" title="Permalink to this headline">¶</a></h3>
<p>This section explains why the reason for the slightly awkward design of <cite>IndexedSubArray</cite>.
The <cite>pynbody</cite> framework requires all sub-arrays to continue pointing to the original data
but a simple experiment with numpy shows that it does not enable this behaviour in all
cases that we want to cover.</p>
<p>Here&#8217;s what happens when you use a slice of an existing <cite>numpy</cite> array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

<span class="gp">In [4]: </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>

<span class="gp">In [5]: </span><span class="n">a</span>
<span class="go"> Out[5]: array([   0.,    0.,    0.,    0.,  100.,    0.,    0.,    0.,    0.,    0.])</span>
</pre></div>
</div>
<p>The <cite>a</cite> array has been updated as required, because the <cite>b</cite> and <cite>a</cite> objects
actually point back to the same part of the computer memory.</p>
<p>On the other hand, when you <em>index</em> a <cite>numpy</cite> array, the behaviour is different.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [6]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

<span class="gp">In [7]: </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>

<span class="gp">In [8]: </span><span class="n">a</span>
<span class="go"> Out[8]: array([   0.,    0.,    0.,    0.,  100.,    0.,    0.,    0.,    0.,    0.])</span>
</pre></div>
</div>
<p>Here changing <cite>c</cite> has not updated <cite>a</cite>. That&#8217;s because the construction of <cite>c</cite> actually
<em>copied</em> the relevant data instead of just pointing back at it.  This is necessitated by
the underlying design of <cite>numpy</cite> arrays requiring the data to lie in a predictable
pattern in the memory.</p>
</div>
<div class="section" id="back-to-pynbody">
<h3>Back to pynbody<a class="headerlink" href="#back-to-pynbody" title="Permalink to this headline">¶</a></h3>
<p>The <cite>IndexedSubArray</cite> class fixes this problem:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="kn">import</span> <span class="nn">pynbody</span>

<span class="gp">In [10]: </span><span class="n">d</span> <span class="o">=</span> <span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">IndexedSimArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="gp">In [11]: </span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>

<span class="gp">In [12]: </span><span class="n">a</span>
<span class="gr">Out[12]: </span><span class="n">array</span><span class="p">([</span>   <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>  <span class="mf">100.</span><span class="p">,</span>  <span class="mf">200.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that <cite>a</cite> has been updated correctly. This is achieved by the <cite>IndexedSimArray</cite>
<em>emulating</em>, rather than <em>wrapping</em>, a <cite>numpy</cite> array; internally
the syntax <cite>d[1]=200</cite> is then translated into <cite>a[[4,5,6][1]]=200</cite>.</p>
<p>The cost of this is that each time you call a function that requires a <cite>numpy</cite> array
as an input, the <cite>IndexedSimArray</cite> has to generate a proxy for this purpose. This can become slow.
Have a look at the following timings:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="o">%</span><span class="n">time</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="p">:</span> <span class="n">d</span><span class="o">+=</span><span class="mi">1</span>
<span class="go">CPU times: user 372 ms, sys: 10 ms, total: 382 ms</span>
<span class="go">Wall time: 375 ms</span>

<span class="gp">In [14]: </span><span class="o">%</span><span class="n">time</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="p">:</span> <span class="n">a</span><span class="o">+=</span><span class="mi">1</span>
<span class="go">CPU times: user 31 ms, sys: 5 ms, total: 36 ms</span>
<span class="go">Wall time: 30.7 ms</span>
</pre></div>
</div>
<p>Adding to the subarray is <em>slower</em> than adding to the entire array!
This is because of the overheads of continually constructing proxy
<cite>numpy</cite> arrays to pass to the <tt class="docutils literal"><span class="pre">__add__</span></tt> method.</p>
</div>
<div class="section" id="how-to-remove-this-bottleneck">
<h3>How to remove this bottleneck<a class="headerlink" href="#how-to-remove-this-bottleneck" title="Permalink to this headline">¶</a></h3>
<p>We should emphasize that the example above is quite contrived, since it forces
re-construction of the <cite>numpy</cite> proxy 10000 times. In user code,
the number of <cite>numpy</cite> proxies that have to be constructed will be vastly smaller,
so the fractional overheads are normally quite small.</p>
<p>Nonetheless, it does sometimes become a problem for performance-critical code.
For that reason, it&#8217;s possible to avoid constructing <cite>IndexedSimArray`s altogether
and force only `numpy</cite> arrays to be returned. This means you must take responsibility
for understanding which operations copy, as opposed to referencing, data.</p>
<p>This is known as <cite>immediate mode</cite> and is activated using python&#8217;s <cite>with</cite> mechanism.
Let&#8217;s create a test snapshot and a subview into that snapshot to try it out.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [15]: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pynbody</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">dm</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">sub_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span>
</pre></div>
</div>
<p>Under normal conditions, the type of arrays returned from <tt class="docutils literal"><span class="pre">sub_f</span></tt> is <tt class="docutils literal"><span class="pre">IndexedSimArray</span></tt>.
Updating one of these arrays will transparently update the main snapshot.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [17]: </span><span class="n">sub_mass</span> <span class="o">=</span> <span class="n">sub_f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>

<span class="gp">In [18]: </span><span class="nb">type</span><span class="p">(</span><span class="n">sub_mass</span><span class="p">)</span>
<span class="gr">Out[18]: </span><span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">IndexedSimArray</span>

<span class="gp">In [19]: </span><span class="n">sub_mass</span><span class="p">[:]</span><span class="o">=</span><span class="mi">3</span>

<span class="gp">In [20]: </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">][[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span>
<span class="gr">Out[20]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</pre></div>
</div>
<p>Conversely, in <cite>immediate mode</cite>, the type of arrays returned from <tt class="docutils literal"><span class="pre">sub_f</span></tt> is <tt class="docutils literal"><span class="pre">SimArray</span></tt> (so just
a wrapper round a real <cite>numpy</cite> array). But updating that returned <cite>numpy</cite> array has <em>no effect</em> on the
parent snapshot.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [21]: </span><span class="k">with</span> <span class="n">f</span><span class="o">.</span><span class="n">immediate_mode</span> <span class="p">:</span>
<span class="gp">   ....:</span>      <span class="n">sub_mass</span> <span class="o">=</span> <span class="n">sub_f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
<span class="gp">   ....:</span> 

<span class="gp">In [22]: </span><span class="nb">type</span><span class="p">(</span><span class="n">sub_mass</span><span class="p">)</span>
<span class="gr">Out[22]: </span><span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">SimArray</span>

<span class="gp">In [23]: </span><span class="n">sub_mass</span>
<span class="gr">Out[23]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>

<span class="gp">In [24]: </span><span class="n">sub_mass</span><span class="p">[:]</span><span class="o">=</span><span class="mi">5</span>

<span class="gp">In [25]: </span><span class="n">sub_mass</span> <span class="c"># updated as expected</span>
<span class="gr">Out[25]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">])</span>

<span class="gp">In [26]: </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">][[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span> <span class="c"># NOT updated - should still be 3,3,3!</span>
<span class="gr">Out[26]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</pre></div>
</div>
<p>So it becomes your responsibility to copy the results back in this case, if required. A template for performance
critical code which might be operating on a <cite>SubSnap</cite> follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">with</span> <span class="pre">f_sub.immediate_mode</span></tt>
is equivalent to <tt class="docutils literal"><span class="pre">with</span> <span class="pre">f.immediate_mode</span></tt> where <cite>f_sub</cite> is any <cite>SubSnap</cite> of <cite>f</cite>.</p>
</div>
<p>So in summary, the template code at the start of this document advocates:</p>
<blockquote>
<div><ul class="simple">
<li>storing a <em>copy</em> of the data for the subset of particles</li>
<li>working on the copy</li>
<li>(if necessary) updating the main snapshot data explicitly before returning</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="overheads-of-raw-simarrays">
<h2>Overheads of raw SimArrays<a class="headerlink" href="#overheads-of-raw-simarrays" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This information is provided for interest. We have never come across a realistic use case
where the following is necessary.</p>
</div>
<p>In <cite>pynbody</cite>, arrays are implemented by the class <a class="reference internal" href="../essentials.html#pynbody.array.SimArray" title="pynbody.array.SimArray"><tt class="xref py py-class docutils literal"><span class="pre">SimArray</span></tt></a>. This is a wrapper
around a <cite>numpy</cite> array. There is a small extra cost associated with every operation to allow
units to be matched and updated. For long arrays such as those found in typical simulations, this is usually a tiny fraction of the
actual computation time. We have never found it to be a problem, but if you want to disable the
unit tracking you can always do so using <cite>numpy</cite>&#8216;s view mechanism to get a raw <cite>numpy</cite> array.
Suppose you have a <cite>SimSnap</cite> <tt class="docutils literal"><span class="pre">f</span></tt>; then <tt class="docutils literal"><span class="pre">pos</span> <span class="pre">=</span> <span class="pre">f['pos'].view(numpy.ndarray)</span></tt> (for example) will return the position
array without any of the <cite>SimArray</cite> wrapping. The new <cite>pos</cite> variable can be manipulated without
any unit handling code being called.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Performance optimisation in pynbody</a><ul>
<li><a class="reference internal" href="#overheads-of-subsnaps">Overheads of SubSnaps</a><ul>
<li><a class="reference internal" href="#a-template-for-performance-critical-code">A template for performance-critical code</a></li>
<li><a class="reference internal" href="#what-is-a-subsnap-really">What is a SubSnap, really?</a></li>
<li><a class="reference internal" href="#numpy-s-behaviour">Numpy&#8217;s behaviour</a></li>
<li><a class="reference internal" href="#back-to-pynbody">Back to pynbody</a></li>
<li><a class="reference internal" href="#how-to-remove-this-bottleneck">How to remove this bottleneck</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overheads-of-raw-simarrays">Overheads of raw SimArrays</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="processing.html"
                        title="previous chapter">Batch-processing Snapshots with Pynbody</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="configuration.html"
                        title="next chapter">Configuring pynbody</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/tutorials/performance.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="configuration.html" title="Configuring pynbody"
             >next</a> |</li>
        <li class="right" >
          <a href="processing.html" title="Batch-processing Snapshots with Pynbody"
             >previous</a> |</li>
        <li><a href="../index.html">pynbody 0.18-alpha documentation</a> &raquo;</li>
          <li><a href="tutorials.html" >Pynbody Tutorials</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-13, pynbody team &lt;http://code.google.com/p/pynbody/people/list&gt;).
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>