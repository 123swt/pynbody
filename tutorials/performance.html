<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Performance optimisation in pynbody &mdash; pynbody 0.20-beta documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.1.0/spacelab/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.20-beta',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="pynbody 0.20-beta documentation" href="../index.html" />
    <link rel="up" title="Pynbody Tutorials" href="tutorials.html" />
    <link rel="next" title="Configuring pynbody" href="configuration.html" />
    <link rel="prev" title="Batch-processing Snapshots with Pynbody" href="processing.html" />

<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38063425-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          pynbody</a>
        <span class="navbar-text navbar-version pull-left"><b>0.20</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Sections <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="tutorials.html">Pynbody tutorials</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../loaders.html">Simulation loaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../essentials.html">Essential generic modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../convenience.html">Convenience modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../derived.html">Derived quantities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../analysis.html">Analysis modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plot.html">Plotting modules</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Performance optimisation in pynbody</a><ul>
<li><a class="reference internal" href="#overheads-of-subsnaps">Overheads of SubSnaps</a><ul>
<li><a class="reference internal" href="#a-template-for-performance-critical-code">A template for performance-critical code</a></li>
<li><a class="reference internal" href="#what-is-a-subsnap-really">What is a SubSnap, really?</a></li>
<li><a class="reference internal" href="#numpy-s-behaviour">Numpy&#8217;s behaviour</a></li>
<li><a class="reference internal" href="#back-to-pynbody">Back to pynbody</a></li>
<li><a class="reference internal" href="#how-to-remove-this-bottleneck">How to remove this bottleneck</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overheads-of-raw-simarrays">Overheads of raw SimArrays</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="processing.html" title="Previous Chapter: Batch-processing Snapshots with Pynbody"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; Batch-processing...</span>
    </a>
  </li>
  <li>
    <a href="configuration.html" title="Next Chapter: Configuring pynbody"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">Configuring pynb... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="performance-optimisation-in-pynbody">
<span id="performance"></span><h1>Performance optimisation in pynbody<a class="headerlink" href="#performance-optimisation-in-pynbody" title="Permalink to this headline">¶</a></h1>
<p><cite>Pynbody</cite> is built on top of <cite>numpy</cite>, which means that learning how to optimize <cite>numpy</cite>
array manipulations is the most important route to writing efficient code; see <a class="reference external" href="http://scipy-lectures.github.com/advanced/optimizing/index.html">http://scipy-lectures.github.com/advanced/optimizing/index.html</a>
for an introduction.</p>
<p>However there are a few issues which are specific to <cite>pynbody</cite>. By far the most important of these
that we have come across is the overheads incurred by using <a href="#id1"><span class="problematic" id="id2">`</span></a>SubSnap`s
which are explained
below.</p>
<div class="section" id="overheads-of-subsnaps">
<h2>Overheads of SubSnaps<a class="headerlink" href="#overheads-of-subsnaps" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-template-for-performance-critical-code">
<h3>A template for performance-critical code<a class="headerlink" href="#a-template-for-performance-critical-code" title="Permalink to this headline">¶</a></h3>
<p>To cut a long story short, if your routine does a lot of array access on an object which might
be a <cite>SubSnap</cite> of a certain flavour (explained further below), you will find that wrapping your
code as follows speeds it up.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">my_expensive_operation</span><span class="p">(</span><span class="n">sim_or_subsim</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">with</span> <span class="n">sim_or_subsim</span><span class="o">.</span><span class="n">immediate_mode</span> <span class="p">:</span>
        <span class="n">mass_array</span> <span class="o">=</span> <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
        <span class="n">other_array</span> <span class="o">=</span> <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;other&#39;</span><span class="p">]</span>
        <span class="c"># ... get other arrays required...</span>

        <span class="c">#</span>
        <span class="c"># perform multiple operations on arrays</span>
        <span class="c">#</span>

        <span class="c"># At end, copy back results if the arrays have</span>
        <span class="c"># changed</span>
        <span class="n">sim_or_subsim</span><span class="p">[</span><span class="s">&#39;other&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_array</span>
</pre></div>
</div>
<p>The remainder of this document unpacks what this does and why it should be necessary.</p>
</div>
<div class="section" id="what-is-a-subsnap-really">
<h3>What is a SubSnap, really?<a class="headerlink" href="#what-is-a-subsnap-really" title="Permalink to this headline">¶</a></h3>
<p>When you construct a <cite>SubSnap</cite>, the framework records which particles of the underlying
<cite>SimSnap</cite> are included and which are not. Thereafter, if you access an array from the <cite>SubSnap</cite>,
it is constructed in one of two ways.</p>
<blockquote>
<div><ul class="simple">
<li>If the set of particles indexed by the <cite>SubSnap</cite> is expressable a slice, the
arrays constructed are still <cite>numpy</cite> arrays.  This will be the case if you explicitly
slice the simulation (e.g. <tt class="docutils literal"><span class="pre">f[2:100:3]</span></tt>), or if you ask for a specific particle family (e.g. <tt class="docutils literal"><span class="pre">f.dm</span></tt>).</li>
<li>If the set of particles is not expressable in this way, the arrays constructed are
emulating <cite>numpy</cite> arrays and this can become expensive (see below). This will
be the cae if you ask for a list of particles (e.g. <tt class="docutils literal"><span class="pre">f[[2,10,15,22]]</span></tt>) use a <cite>numpy</cite>-like
indexing trick (e.g. <tt class="docutils literal"><span class="pre">f[f['x']&gt;10]</span></tt> or <tt class="docutils literal"><span class="pre">f[numpy.where(f['x']&gt;10)]</span></tt>) or use a
<a class="reference internal" href="../convenience.html#module-pynbody.filt" title="pynbody.filt"><tt class="xref py py-mod docutils literal"><span class="pre">filter</span></tt></a>.</li>
</ul>
</div></blockquote>
<p>In the first case, the optimization is unchanged from the raw <cite>SimSnap</cite> case.
In the second case, the situation is different.
To understand how and why, we
need to look at the difference between an indexed and a sliced <cite>numpy</cite> array.</p>
</div>
<div class="section" id="numpy-s-behaviour">
<h3>Numpy&#8217;s behaviour<a class="headerlink" href="#numpy-s-behaviour" title="Permalink to this headline">¶</a></h3>
<p>This section explains why the reason for the slightly awkward design of <cite>IndexedSubArray</cite>.
The <cite>pynbody</cite> framework requires all sub-arrays to continue pointing to the original data
but a simple experiment with numpy shows that it does not enable this behaviour in all
cases that we want to cover.</p>
<p>Here&#8217;s what happens when you use a slice of an existing <cite>numpy</cite> array.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="gp">In [3]: </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>

<span class="gp">In [4]: </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>

<span class="gp">In [5]: </span><span class="n">a</span>
<span class="go"> Out[5]: array([   0.,    0.,    0.,    0.,  100.,    0.,    0.,    0.,    0.,    0.])</span>
</pre></div>
</div>
<p>The <cite>a</cite> array has been updated as required, because the <cite>b</cite> and <cite>a</cite> objects
actually point back to the same part of the computer memory.</p>
<p>On the other hand, when you <em>index</em> a <cite>numpy</cite> array, the behaviour is different.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [6]: </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

<span class="gp">In [7]: </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>

<span class="gp">In [8]: </span><span class="n">a</span>
<span class="go"> Out[8]: array([   0.,    0.,    0.,    0.,  100.,    0.,    0.,    0.,    0.,    0.])</span>
</pre></div>
</div>
<p>Here changing <cite>c</cite> has not updated <cite>a</cite>. That&#8217;s because the construction of <cite>c</cite> actually
<em>copied</em> the relevant data instead of just pointing back at it.  This is necessitated by
the underlying design of <cite>numpy</cite> arrays requiring the data to lie in a predictable
pattern in the memory.</p>
</div>
<div class="section" id="back-to-pynbody">
<h3>Back to pynbody<a class="headerlink" href="#back-to-pynbody" title="Permalink to this headline">¶</a></h3>
<p>The <cite>IndexedSubArray</cite> class fixes this problem:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [9]: </span><span class="kn">import</span> <span class="nn">pynbody</span>

<span class="gp">In [10]: </span><span class="n">d</span> <span class="o">=</span> <span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">IndexedSimArray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>

<span class="gp">In [11]: </span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>

<span class="gp">In [12]: </span><span class="n">a</span>
<span class="gr">Out[12]: </span><span class="n">array</span><span class="p">([</span>   <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>  <span class="mf">100.</span><span class="p">,</span>  <span class="mf">200.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">,</span>    <span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that <cite>a</cite> has been updated correctly. This is achieved by the <cite>IndexedSimArray</cite>
<em>emulating</em>, rather than <em>wrapping</em>, a <cite>numpy</cite> array; internally
the syntax <cite>d[1]=200</cite> is then translated into <cite>a[[4,5,6][1]]=200</cite>.</p>
<p>The cost of this is that each time you call a function that requires a <cite>numpy</cite> array
as an input, the <cite>IndexedSimArray</cite> has to generate a proxy for this purpose. This can become slow.
Have a look at the following timings:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [13]: </span><span class="o">%</span><span class="n">time</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="p">:</span> <span class="n">d</span><span class="o">+=</span><span class="mi">1</span>
<span class="go">CPU times: user 202 ms, sys: 10 ms, total: 212 ms</span>
<span class="go">Wall time: 205 ms</span>

<span class="gp">In [14]: </span><span class="o">%</span><span class="n">time</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="p">:</span> <span class="n">a</span><span class="o">+=</span><span class="mi">1</span>
<span class="go">CPU times: user 19.4 ms, sys: 864 us, total: 20.3 ms</span>
<span class="go">Wall time: 19.5 ms</span>
</pre></div>
</div>
<p>Adding to the subarray is <em>slower</em> than adding to the entire array!
This is because of the overheads of continually constructing proxy
<cite>numpy</cite> arrays to pass to the <tt class="docutils literal"><span class="pre">__add__</span></tt> method.</p>
</div>
<div class="section" id="how-to-remove-this-bottleneck">
<h3>How to remove this bottleneck<a class="headerlink" href="#how-to-remove-this-bottleneck" title="Permalink to this headline">¶</a></h3>
<p>We should emphasize that the example above is quite contrived, since it forces
re-construction of the <cite>numpy</cite> proxy 10000 times. In user code,
the number of <cite>numpy</cite> proxies that have to be constructed will be vastly smaller,
so the fractional overheads are normally quite small.</p>
<p>Nonetheless, it does sometimes become a problem for performance-critical code.
For that reason, it&#8217;s possible to avoid constructing <cite>IndexedSimArray`s altogether
and force only `numpy</cite> arrays to be returned. This means you must take responsibility
for understanding which operations copy, as opposed to referencing, data.</p>
<p>This is known as <cite>immediate mode</cite> and is activated using python&#8217;s <cite>with</cite> mechanism.
Let&#8217;s create a test snapshot and a subview into that snapshot to try it out.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [15]: </span><span class="n">f</span> <span class="o">=</span> <span class="n">pynbody</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">dm</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="gp">In [16]: </span><span class="n">sub_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span>
</pre></div>
</div>
<p>Under normal conditions, the type of arrays returned from <tt class="docutils literal"><span class="pre">sub_f</span></tt> is <tt class="docutils literal"><span class="pre">IndexedSimArray</span></tt>.
Updating one of these arrays will transparently update the main snapshot.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [17]: </span><span class="n">sub_mass</span> <span class="o">=</span> <span class="n">sub_f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>

<span class="gp">In [18]: </span><span class="nb">type</span><span class="p">(</span><span class="n">sub_mass</span><span class="p">)</span>
<span class="gr">Out[18]: </span><span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">IndexedSimArray</span>

<span class="gp">In [19]: </span><span class="n">sub_mass</span><span class="p">[:]</span><span class="o">=</span><span class="mi">3</span>

<span class="gp">In [20]: </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">][[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span>
<span class="gr">Out[20]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</pre></div>
</div>
<p>Conversely, in <cite>immediate mode</cite>, the type of arrays returned from <tt class="docutils literal"><span class="pre">sub_f</span></tt> is <tt class="docutils literal"><span class="pre">SimArray</span></tt> (so just
a wrapper round a real <cite>numpy</cite> array). But updating that returned <cite>numpy</cite> array has <em>no effect</em> on the
parent snapshot.</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [21]: </span><span class="k">with</span> <span class="n">f</span><span class="o">.</span><span class="n">immediate_mode</span> <span class="p">:</span>
<span class="gp">   ....:</span>      <span class="n">sub_mass</span> <span class="o">=</span> <span class="n">sub_f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">]</span>
<span class="gp">   ....:</span> 

<span class="gp">In [22]: </span><span class="nb">type</span><span class="p">(</span><span class="n">sub_mass</span><span class="p">)</span>
<span class="gr">Out[22]: </span><span class="n">pynbody</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">SimArray</span>

<span class="gp">In [23]: </span><span class="n">sub_mass</span>
<span class="gr">Out[23]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>

<span class="gp">In [24]: </span><span class="n">sub_mass</span><span class="p">[:]</span><span class="o">=</span><span class="mi">5</span>

<span class="gp">In [25]: </span><span class="n">sub_mass</span> <span class="c"># updated as expected</span>
<span class="gr">Out[25]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">,</span>  <span class="mf">5.</span><span class="p">])</span>

<span class="gp">In [26]: </span><span class="n">f</span><span class="p">[</span><span class="s">&#39;mass&#39;</span><span class="p">][[</span><span class="mi">20</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]]</span> <span class="c"># NOT updated - should still be 3,3,3!</span>
<span class="gr">Out[26]: </span><span class="n">SimArray</span><span class="p">([</span> <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">,</span>  <span class="mf">3.</span><span class="p">])</span>
</pre></div>
</div>
<p>So it becomes your responsibility to copy the results back in this case, if required. A template for performance
critical code which might be operating on a <cite>SubSnap</cite> follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">with</span> <span class="pre">f_sub.immediate_mode</span></tt>
is equivalent to <tt class="docutils literal"><span class="pre">with</span> <span class="pre">f.immediate_mode</span></tt> where <cite>f_sub</cite> is any <cite>SubSnap</cite> of <cite>f</cite>.</p>
</div>
<p>So in summary, the template code at the start of this document advocates:</p>
<blockquote>
<div><ul class="simple">
<li>storing a <em>copy</em> of the data for the subset of particles</li>
<li>working on the copy</li>
<li>(if necessary) updating the main snapshot data explicitly before returning</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="overheads-of-raw-simarrays">
<h2>Overheads of raw SimArrays<a class="headerlink" href="#overheads-of-raw-simarrays" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This information is provided for interest. We have never come across a realistic use case
where the following is necessary.</p>
</div>
<p>In <cite>pynbody</cite>, arrays are implemented by the class <a class="reference internal" href="../essentials.html#pynbody.array.SimArray" title="pynbody.array.SimArray"><tt class="xref py py-class docutils literal"><span class="pre">SimArray</span></tt></a>. This is a wrapper
around a <cite>numpy</cite> array. There is a small extra cost associated with every operation to allow
units to be matched and updated. For long arrays such as those found in typical simulations, this is usually a tiny fraction of the
actual computation time. We have never found it to be a problem, but if you want to disable the
unit tracking you can always do so using <cite>numpy</cite>&#8216;s view mechanism to get a raw <cite>numpy</cite> array.
Suppose you have a <cite>SimSnap</cite> <tt class="docutils literal"><span class="pre">f</span></tt>; then <tt class="docutils literal"><span class="pre">pos</span> <span class="pre">=</span> <span class="pre">f['pos'].view(numpy.ndarray)</span></tt> (for example) will return the position
array without any of the <cite>SimArray</cite> wrapping. The new <cite>pos</cite> variable can be manipulated without
any unit handling code being called.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/tutorials/performance.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2011-14, pynbody team https://github.com/pynbody/pynbody/graphs/contributors.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2b1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>