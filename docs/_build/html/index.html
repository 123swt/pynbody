

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to pynbody’s documentation! &mdash; pynbody v0.13-alpha documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.13-alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pynbody v0.13-alpha documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pynbody v0.13-alpha documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-pynbody-s-documentation">
<h1>Welcome to pynbody&#8217;s documentation!<a class="headerlink" href="#welcome-to-pynbody-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-pynbody"></span><div class="section" id="pynbody">
<h2>pynbody<a class="headerlink" href="#pynbody" title="Permalink to this headline">¶</a></h2>
<p>A light-weight, portable, format-transparent analysis framework
for N-body and SPH astrophysical simulations.</p>
<div class="section" id="getting-help">
<h3>Getting help<a class="headerlink" href="#getting-help" title="Permalink to this headline">¶</a></h3>
<p>Help for pynbody comes in two forms</p>
<blockquote>
<div><ol class="arabic">
<li><dl class="first docutils">
<dt>The wiki, which is recommended for new users, at</dt>
<dd><p class="first last">&lt;<a class="reference external" href="http://tinyurl.com/pynbody">http://tinyurl.com/pynbody</a>&gt;</p>
</dd>
</dl>
</li>
<li><p class="first">docstrings in the code for reference, which can be accessed
using the standard help() function</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="what-s-available">
<h3>What&#8217;s available<a class="headerlink" href="#what-s-available" title="Permalink to this headline">¶</a></h3>
<p>Pynbody handles Gadget, Gadget-HDF and Tipsy files. To load
any of these, use</p>
<p>f = pynbody.load(filename)</p>
<p>to create a pynbody.snapshot.SimSnap object f, which then acts
as a dictionary holding the arrays inside f. For more information
see &lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/BasicTutorial">http://code.google.com/p/pynbody/wiki/BasicTutorial</a>&gt;.</p>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>Various aspects of the behaviour of pynbody can be controlled.
See &lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/ConfigFiles">http://code.google.com/p/pynbody/wiki/ConfigFiles</a>&gt;</p>
</div>
<div class="section" id="subpackages">
<h3>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><a class="reference internal" href="#module-pynbody.array" title="pynbody.array"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a></dt>
<dd>Extends numpy arrays with a custom class array.SimArray
which holds additional information like units.</dd>
<dt><a class="reference internal" href="#module-pynbody.bridge" title="pynbody.bridge"><tt class="xref py py-mod docutils literal"><span class="pre">bridge</span></tt></a></dt>
<dd>Allows connections to be made between two different
SimSnap objects in various ways. 
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/SameSimulationDifferentOutputs">http://code.google.com/p/pynbody/wiki/SameSimulationDifferentOutputs</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.derived" title="pynbody.derived"><tt class="xref py py-mod docutils literal"><span class="pre">derived</span></tt></a></dt>
<dd>Holds procedures for creating new arrays from existing
ones, e.g. for getting the radial position. 
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/AutomagicCalculation">http://code.google.com/p/pynbody/wiki/AutomagicCalculation</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.family" title="pynbody.family"><tt class="xref py py-mod docutils literal"><span class="pre">family</span></tt></a></dt>
<dd>Stores a registry of different particle types like dm,
star, gas.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/TheFamilySystem">http://code.google.com/p/pynbody/wiki/TheFamilySystem</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.filt" title="pynbody.filt"><tt class="xref py py-mod docutils literal"><span class="pre">filt</span></tt></a></dt>
<dd>Defines and implements &#8216;filters&#8217; which allow abstract subsets
of data to be specified.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/FiltersAndSubsims">http://code.google.com/p/pynbody/wiki/FiltersAndSubsims</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.gadget" title="pynbody.gadget"><tt class="xref py py-mod docutils literal"><span class="pre">gadget</span></tt></a></dt>
<dd>Implements classes and functions for handling gadget files;
you rarely need to access this module directly as it will
be invoked automatically via pynbody.load.</dd>
<dt><a class="reference internal" href="#module-pynbody.gadgethdf" title="pynbody.gadgethdf"><tt class="xref py py-mod docutils literal"><span class="pre">gadgethdf</span></tt></a></dt>
<dd>Implements classes and functions for handling gadget HDF files
(if h5py is installed); you rarely need to access this module
directly as it will be invoked automatically via pynbody.load</dd>
<dt><a class="reference internal" href="#module-pynbody.halo" title="pynbody.halo"><tt class="xref py py-mod docutils literal"><span class="pre">halo</span></tt></a></dt>
<dd>Implements halo catalogue functions. If you have a supported
halo catalogue on disk or a halo finder installed and
correctly configured, you can access a halo catalogue through
f.halos() where f is a SimSnap.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/HaloCatalogue">http://code.google.com/p/pynbody/wiki/HaloCatalogue</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.kdtree" title="pynbody.kdtree"><tt class="xref py py-mod docutils literal"><span class="pre">kdtree</span></tt></a></dt>
<dd>Implements a KD Tree based on Joachim Stadel&#8217;s smooth.c.
You are unlikely to need to access this module directly
as KD Trees are built in higher level analysis code
automatically.</dd>
<dt><a class="reference internal" href="#module-pynbody.snapshot" title="pynbody.snapshot"><tt class="xref py py-mod docutils literal"><span class="pre">snapshot</span></tt></a></dt>
<dd>Implements the basic SimSnap class and also SubSnap classes
which can represent different views of the same data.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/FiltersAndSubsims">http://code.google.com/p/pynbody/wiki/FiltersAndSubsims</a>&gt;
You rarely need to access this module directly.</dd>
<dt><a class="reference internal" href="#module-pynbody.sph" title="pynbody.sph"><tt class="xref py py-mod docutils literal"><span class="pre">sph</span></tt></a></dt>
<dd>Allows SPH images to be rendered. The easiest interface
to this module, at least to start with, is through the
pynbody.plot package.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/SphImages">http://code.google.com/p/pynbody/wiki/SphImages</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.tipsy" title="pynbody.tipsy"><tt class="xref py py-mod docutils literal"><span class="pre">tipsy</span></tt></a></dt>
<dd>Implements classes and functions for handling tipsy files.
You rarely need to access this module directly as it will
be invoked automatically via pynbody.load.</dd>
<dt><a class="reference internal" href="#module-pynbody.units" title="pynbody.units"><tt class="xref py py-mod docutils literal"><span class="pre">units</span></tt></a></dt>
<dd>Implements a light-weight unit class which is
used to automatically track units of your simulation arrays.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/ConvertingUnits">http://code.google.com/p/pynbody/wiki/ConvertingUnits</a>&gt;</dd>
<dt><a class="reference internal" href="#module-pynbody.util" title="pynbody.util"><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt></a></dt>
<dd>Various utility routines used internally by pynbody.</dd>
</dl>
<span class="target" id="module-pynbody.array"></span><div class="section" id="array">
<h4>array<a class="headerlink" href="#array" title="Permalink to this headline">¶</a></h4>
<p>Defines a shallow wrapper around numpy.ndarray for extra functionality like unit-tracking.</p>
<p>For most purposes, the differences between numpy.ndarray and
array.SimArray are not important. However, when units are specified
(by setting the <tt class="docutils literal"><span class="pre">units</span></tt> attribute), the behaviour is slightly
different. In particular,</p>
<ul class="simple">
<li>it becomes impossible to add or subtract arrays with incompatible dimensions</li>
</ul>
<blockquote>
<div><tt class="docutils literal"><span class="pre">SimArray([1,2],</span> <span class="pre">&quot;Mpc&quot;)</span> <span class="pre">+</span> <span class="pre">SimArray([1,2],</span> <span class="pre">&quot;Msol&quot;))</span> <span class="pre">#</span> <span class="pre">-&gt;ValueError</span></tt></div></blockquote>
<ul class="simple">
<li>addition or subtraction causes auto-unit conversion. For example</li>
</ul>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">SimArray([1,2],</span> <span class="pre">&quot;Mpc&quot;)</span> <span class="pre">+</span> <span class="pre">SimArray([1,2],</span> <span class="pre">&quot;kpc&quot;)</span></tt></p>
<p>yields <tt class="docutils literal"><span class="pre">SimArray([1.001,</span> <span class="pre">1.002],</span> <span class="pre">&quot;Mpc&quot;)</span></tt></p>
</div></blockquote>
<ul>
<li><p class="first">Note that in this context the left value takes precedence in
specifying the return units, so that reversing the order of the
operation here would return results in kpc.</p>
</li>
<li><p class="first">If only one of the arrays specifies a Unit, no checking occurs and
the unit of the returned array is assumed to be the same as the one
specified input unit.</p>
</li>
<li><p class="first">Powers to single integer or rational powers will maintain unit
tracking.  Powers to float or other powers will not be able to do
so.</p>
<p>SimArray([1,2],&#8221;Msol Mpc**-3&#8221;)**2 # -&gt; SimArray([1, 4], &#8216;Msol**2 Mpc**-6&#8217;)
SimArray([1,2],&#8221;Msol Mpc**-3&#8221;)**(1,3) # -&gt; SimArray([ 1.,1.26], &#8216;Msol**1/3 Mpc**-1&#8217;)</p>
<blockquote>
<div><p># Syntax above mirrors syntax in units module, where a length-two tuple
# can represent a rational number, in this case one third.</p>
<p>SimArray([1.,2], &#8220;Msol Mpc**-3&#8221;)**0.333 # -&gt; SimArray([ 1.,1.26])
# Lost track of units</p>
</div></blockquote>
</li>
</ul>
<div class="section" id="getting-the-array-in-specified-units">
<h5>Getting the array in specified units<a class="headerlink" href="#getting-the-array-in-specified-units" title="Permalink to this headline">¶</a></h5>
<p>Given an array, you can convert it in-place into units of your
own chosing:</p>
<blockquote>
<div>x = SimArray([1,2], &#8220;Msol&#8221;)
x.convert_units(&#8216;kg&#8217;)
print x # -&gt;  SimArray([  1.99e+30,   3.98e+30], &#8216;kg&#8217;)</div></blockquote>
<p>Or you can leave the original array alone and get a <em>copy</em> in
different units, correctly converted:</p>
<blockquote>
<div>x = SimArray([1,2], &#8220;Msol&#8221;)
print x.in_units(&#8220;kg&#8221;) # -&gt; SimArray([  1.99e+30,   3.98e+30], &#8216;kg&#8217;)
print x # -&gt; SimArray([1,2], &#8220;Msol&#8221;)</div></blockquote>
<p>If the SimArray was created by a SimSnap (which is most likely), it
has a pointer into the SimSnap&#8217;s properties so that the cosmological
context is automatically fetched. For example, comoving -&gt; physical
conversions are correctly achieved:</p>
<blockquote>
<div><p>f = pynbody.load(&#8220;fname&#8221;)
f[&#8216;pos&#8217;]</p>
<dl class="docutils">
<dt>SimArray([[ 0.05419805, -0.0646539 , -0.15700017],</dt>
<dd>[ 0.05169899, -0.06193341, -0.14475258],
[ 0.05672406, -0.06384531, -0.15909944],
...,
[ 0.0723075 , -0.07650762, -0.07657281],
[ 0.07166634, -0.07453796, -0.08020873],
[ 0.07165282, -0.07468577, -0.08020587]], &#8216;2.86e+04 kpc a&#8217;)</dd>
</dl>
<p>f[&#8216;pos&#8217;].convert_units(&#8216;kpc&#8217;)
f[&#8216;pos&#8217;]</p>
<blockquote>
<div><dl class="docutils">
<dt>SimArray([[ 1548.51403101, -1847.2525312 , -4485.71463308],</dt>
<dd>[ 1477.1124212 , -1769.52421398, -4135.78377699],
[ 1620.68592366, -1824.15000686, -4545.69387564],
...,
[ 2065.9264273 , -2185.92982874, -2187.79225915],
[ 2047.60759667, -2129.6537339 , -2291.6758134 ],
[ 2047.2214441 , -2133.87693163, -2291.59406997]], &#8216;kpc&#8217;)</dd>
</dl>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="specifying-rules-for-ufunc-s">
<h5>Specifying rules for ufunc&#8217;s<a class="headerlink" href="#specifying-rules-for-ufunc-s" title="Permalink to this headline">¶</a></h5>
<p>In general, it&#8217;s not possible to infer what the output units from a given
ufunc should be. While numpy built-in ufuncs should be handled OK, other
ufuncs will need their output units defined (otherwise a numpy.ndarray
will be returned instead of our custom type.)</p>
<p>To do this, decorate a function with SimArray.ufunc_rule(ufunc). The function
you define should take the same number of parameters as the ufunc. These will
be the input parameters of the ufunc. You should return the correct units for
the output, or raise units.UnitsException (in the latter case, the return
array will be made into a numpy.ndarray.)</p>
<p>For example, here is the code for the correct addition/subtraction
handler:</p>
<blockquote>
<div><p>&#64;SimArray.ufunc_rule(np.add)
&#64;SimArray.ufunc_rule(np.subtract)
def _consistent_units(a,b) :</p>
<blockquote>
<div><p># This will be called whenever the standard numpy ufuncs np.add
# or np.subtract are called with parameters a,b.</p>
<p># You should always be ready for the inputs to have no units.</p>
<p>a_units = a.units if hasattr(a, &#8216;units&#8217;) else None
b_units = b.units if hasattr(b, &#8216;units&#8217;) else None</p>
<p># Now do the logic. If we&#8217;re adding incompatible units,
# we want just to get a plain numpy array out. If we only
# know the units of one of the arrays, we assume the output
# is in those units.</p>
<dl class="docutils">
<dt>if a_units is not None and b_units is not None :</dt>
<dd><dl class="first last docutils">
<dt>if a_units==b_units :</dt>
<dd>return a_units</dd>
<dt>else :</dt>
<dd>raise units.UnitsException(&#8220;Incompatible units&#8221;)</dd>
</dl>
</dd>
<dt>elif a_units is not None :</dt>
<dd>return a_units</dd>
<dt>else :</dt>
<dd>return b_units</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="attribute">
<dt id="pynbody.array.w">
<tt class="descclassname">pynbody.array.</tt><tt class="descname">w</tt><a class="headerlink" href="#pynbody.array.w" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as self.transpose(), except that self is returned if
self.ndim &lt; 2.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">],[</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[ 1.,  2.],</span>
<span class="go">       [ 3.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([[ 1.,  3.],</span>
<span class="go">       [ 2.,  4.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([ 1.,  2.,  3.,  4.])</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.bridge"></span><div class="section" id="bridge">
<h4>bridge<a class="headerlink" href="#bridge" title="Permalink to this headline">¶</a></h4>
<p>The bridge module has tools for connecting different outputs. For instance,
it&#8217;s possible to take a subview (e.g. a halo) from one snapshot and &#8216;push&#8217;
it into the other. This is especially useful if the two snapshots are
different time outputs of the same simulation.</p>
<div class="section" id="basic-usage">
<h5>Basic usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h5>
<p>f1 = pynbody.load(high_redshift_file)
f2 = pynbody.load(low_redshift_file)
b = pynbody.bridge.OrderBridge(f1, f2) # Or a different class, see &#8220;Which class to use&#8221; below</p>
<p>h = f1.halos() # load the halo catalogue from high redshift step
h1_at_low_z = b(h[1])
# h1_at_low_z now contains the particles which were in h[1] in the high redshift output</p>
<p>h_low_z = f2.halos()
h1_at_high_z = b(h_low_z[1])
# h1_at_high_z now contains the particles which will be in h[1] at low redshift output</p>
</div>
<div class="section" id="identifying-halos-between-different-outputs">
<h5>Identifying halos between different outputs<a class="headerlink" href="#identifying-halos-between-different-outputs" title="Permalink to this headline">¶</a></h5>
<p>You may wish to work out how a halo catalogue maps onto a halo
catalogue for a different output. For this purpose a simple function,
match_catalog, is provided. Extending the example above,
this would be called as follows:</p>
<p>cat = b.match_catalog()</p>
<p>cat is now a numpy index array such that f1.halos()[i] is (probably!) the
major progenitor for f2.halos()[cat[i]].</p>
</div>
<div class="section" id="which-class-to-use">
<h5>Which class to use<a class="headerlink" href="#which-class-to-use" title="Permalink to this headline">¶</a></h5>
<p>For files where the particle ordering is static, so that the particle with
index i in the first snapshot also has index i in the second snapshot, use the Bridge
class.</p>
<p>For files which can spawn new particles, and therefore have a monotonically
increasing particle ordering array (e.g. &#8220;iord&#8221; in gasoline), use the
OrderBridge class.</p>
<p>Snapshot formats where the particle ordering can change are not currently supported.</p>
<dl class="class">
<dt id="pynbody.bridge.OrderBridge">
<em class="property">class </em><tt class="descclassname">pynbody.bridge.</tt><tt class="descname">OrderBridge</tt><big>(</big><em>start</em>, <em>end</em>, <em>order_array='iord'</em><big>)</big><a class="reference internal" href="_modules/pynbody/bridge.html#OrderBridge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.bridge.OrderBridge" title="Permalink to this definition">¶</a></dt>
<dd><p>An OrderBridge uses integer arrays in two simulations
(start,end) where particles i_start and i_end are
defined to be the same if and only if
start[order_array][i_start] == start[order_array][i_end].</p>
<p>order_array must be monotonically increasing in both ends
of the bridge.</p>
</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.derived"></span><div class="section" id="derived">
<h4>derived<a class="headerlink" href="#derived" title="Permalink to this headline">¶</a></h4>
<p>Holds procedures for creating new arrays from existing ones, e.g. for
getting the radial position.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/AutomagicCalculation">http://code.google.com/p/pynbody/wiki/AutomagicCalculation</a>&gt;</p>
<dl class="function">
<dt id="pynbody.derived.alt">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">alt</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#alt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.alt" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle from the horizon, from [-pi/2:pi/2]</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.az">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">az</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#az"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.az" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle in the xy plane from the x axis, from [-pi:pi]</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.j">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">j</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#j"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.j" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific angular momentum</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.ke">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">ke</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#ke"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.ke" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific kinetic energy</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.te">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">te</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#te"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.te" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific total energy</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.theta">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">theta</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#theta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.theta" title="Permalink to this definition">¶</a></dt>
<dd><p>Angle from the z axis, from [0:2pi]</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.v2">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">v2</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#v2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.v2" title="Permalink to this definition">¶</a></dt>
<dd><p>Squared velocity</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.vr">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">vr</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#vr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.vr" title="Permalink to this definition">¶</a></dt>
<dd><p>Radial velocity</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.derived.vt">
<tt class="descclassname">pynbody.derived.</tt><tt class="descname">vt</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/derived.html#vt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.derived.vt" title="Permalink to this definition">¶</a></dt>
<dd><p>Tangential velocity</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.family"></span><div class="section" id="family">
<h4>family<a class="headerlink" href="#family" title="Permalink to this headline">¶</a></h4>
<p>This module defines the Family class which represents
families of particles (e.g. dm, gas, star particles).
New Family objects are automatically registered so that
snapshots can use them in the normal syntax (snap.dm,
snap.star, etc).</p>
<p>In practice the easiest way to make use of the flexibility
this module provides is through adding more families of
particles in your config.ini.</p>
<dl class="function">
<dt id="pynbody.family.family_names">
<tt class="descclassname">pynbody.family.</tt><tt class="descname">family_names</tt><big>(</big><em>with_aliases=False</em><big>)</big><a class="reference internal" href="_modules/pynbody/family.html#family_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.family.family_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the names of all particle families.
If with_aliases is True, include aliases in the list.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.family.get_family">
<tt class="descclassname">pynbody.family.</tt><tt class="descname">get_family</tt><big>(</big><em>name</em>, <em>create=False</em><big>)</big><a class="reference internal" href="_modules/pynbody/family.html#get_family"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.family.get_family" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a family corresponding to the specified string.  If the
family does not exist and create is False, raises ValueError. If
the family does not exist and create is True, an appropriate
object is instantiated, registered and returned.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.filt"></span><div class="section" id="filt">
<h4>filt<a class="headerlink" href="#filt" title="Permalink to this headline">¶</a></h4>
<p>Defines and implements &#8216;filters&#8217; which allow abstract subsets
of data to be specified.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/FiltersAndSubsims">http://code.google.com/p/pynbody/wiki/FiltersAndSubsims</a>&gt;</p>
</div>
<span class="target" id="module-pynbody.gadget"></span><div class="section" id="gadget">
<h4>gadget<a class="headerlink" href="#gadget" title="Permalink to this headline">¶</a></h4>
<p>Implements classes and functions for handling gadget files; you rarely
need to access this module directly as it will be invoked
automatically via pynbody.load.</p>
<dl class="class">
<dt id="pynbody.gadget.GadgetBlock">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">GadgetBlock</tt><big>(</big><em>start=0, length=0, partlen=0, dtype=&lt;type 'numpy.float32'&gt;, p_types=array([False, False, False, False, False, False], dtype=bool)</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetBlock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Class to describe each block.
Each block has a start, a length, and a length-per-particle</p>
</dd></dl>

<dl class="class">
<dt id="pynbody.gadget.GadgetFile">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">GadgetFile</tt><big>(</big><em>filename</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a helper class.
Should only be called by GadgetSnap.
Contains the block location dictionary for each file.
To read Gadget 1 format files, use the gadget-1-blocks config entry</p>
<dl class="method">
<dt id="pynbody.gadget.GadgetFile.add_file_block">
<tt class="descname">add_file_block</tt><big>(</big><em>name</em>, <em>blocksize</em>, <em>partlen=4</em>, <em>dtype=&lt;type 'numpy.float32'&gt;</em>, <em>p_types=-1</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.add_file_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.add_file_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a block to the block table at the end of the file. Do not actually write anything</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.check_format">
<tt class="descname">check_format</tt><big>(</big><em>fd</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.check_format"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.check_format" title="Permalink to this definition">¶</a></dt>
<dd><p>This function reads the first character of a file and, depending on its value, determines
whether we have a format 1 or 2 file, and whether the endianness is swapped. For the endianness,
it then determines the correct byteorder string to pass to struct.unpack. There is not string
for &#8216;not native&#8217;, so this is more complex than it needs to be</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.get_block">
<tt class="descname">get_block</tt><big>(</big><em>name</em>, <em>p_type</em>, <em>p_toread</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.get_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.get_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a particle range from this file, starting at p_start,
and reading a maximum of p_toread particles</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.get_block_dims">
<tt class="descname">get_block_dims</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.get_block_dims"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.get_block_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimensionality of the block, eg, 3 for POS, 1 for most other things</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.get_block_parts">
<tt class="descname">get_block_parts</tt><big>(</big><em>name</em>, <em>p_type</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.get_block_parts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.get_block_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of particles present in a block in this file</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.get_block_types">
<tt class="descname">get_block_types</tt><big>(</big><em>block</em>, <em>npart</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.get_block_types"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.get_block_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up the particle types in the block, with a heuristic,
which assumes that blocks are either fully present or not for a given particle type</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.get_start_part">
<tt class="descname">get_start_part</tt><big>(</big><em>name</em>, <em>p_type</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.get_start_part"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.get_start_part" title="Permalink to this definition">¶</a></dt>
<dd><p>Find particle to skip to before starting, if reading particular type</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.read_block_foot">
<tt class="descname">read_block_foot</tt><big>(</big><em>fd</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.read_block_foot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.read_block_foot" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpacks the block footer, into a single integer</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.read_block_head">
<tt class="descname">read_block_head</tt><big>(</big><em>fd</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.read_block_head"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.read_block_head" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the Gadget 2 &#8220;block header&#8221; record, ie, 8 name, length, 8.
Takes an open file and returns a (name, length) tuple</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.write_block">
<tt class="descname">write_block</tt><big>(</big><em>name</em>, <em>p_type</em>, <em>big_data</em>, <em>filename=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.write_block"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.write_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a full block of data in this file. Any particle type can be written. If the particle type is not present in this file, 
an exception KeyError is thrown. If there are too many particles, ValueError is thrown. 
big_data contains a reference to the data to be written. Type -1 is all types</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.write_block_footer">
<tt class="descname">write_block_footer</tt><big>(</big><em>name</em>, <em>blocksize</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.write_block_footer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.write_block_footer" title="Permalink to this definition">¶</a></dt>
<dd><p>(Re) write a Gadget-style block footer.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.write_block_header">
<tt class="descname">write_block_header</tt><big>(</big><em>name</em>, <em>blocksize</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.write_block_header"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.write_block_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a string for a Gadget-style block header, but do not actually write it, for atomicity.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetFile.write_header">
<tt class="descname">write_header</tt><big>(</big><em>head_in</em>, <em>filename=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetFile.write_header"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetFile.write_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a file header. Overwrites npart in the argument with the npart of the file, so a consistent file is always written.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynbody.gadget.GadgetHeader">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">GadgetHeader</tt><big>(</big><em>npart</em>, <em>mass</em>, <em>time</em>, <em>redshift</em>, <em>BoxSize</em>, <em>Omega0</em>, <em>OmegaLambda</em>, <em>HubbleParam</em>, <em>num_files=1</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetHeader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetHeader" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes the header of gadget class files; this is all our metadata, so we are going to store it inline</p>
<dl class="method">
<dt id="pynbody.gadget.GadgetHeader.serialize">
<tt class="descname">serialize</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetHeader.serialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetHeader.serialize" title="Permalink to this definition">¶</a></dt>
<dd><p>This takes the header structure and returns it as a packed string</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynbody.gadget.GadgetSnap">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">GadgetSnap</tt><big>(</big><em>filename</em>, <em>only_header=False</em>, <em>must_have_paramfile=False</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Main class for reading Gadget-2 snapshots. The constructor makes a map of the locations
of the blocks, which are then read by _load_array</p>
<dl class="method">
<dt id="pynbody.gadget.GadgetSnap.check_headers">
<tt class="descname">check_headers</tt><big>(</big><em>head1</em>, <em>head2</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetSnap.check_headers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetSnap.check_headers" title="Permalink to this definition">¶</a></dt>
<dd><p>Check two headers for consistency</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetSnap.get_block_list">
<tt class="descname">get_block_list</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetSnap.get_block_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetSnap.get_block_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of unique blocks in snapshot, with the types they refer to</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetSnap.get_block_parts">
<tt class="descname">get_block_parts</tt><big>(</big><em>name</em>, <em>family</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetSnap.get_block_parts"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetSnap.get_block_parts" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of particles present in a block, of a given type</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.gadget.GadgetSnap.loadable_family_keys">
<tt class="descname">loadable_family_keys</tt><big>(</big><em>fam=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetSnap.loadable_family_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetSnap.loadable_family_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of arrays which are loadable for specific families, 
but not for all families.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynbody.gadget.GadgetWriteFile">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">GadgetWriteFile</tt><big>(</big><em>filename</em>, <em>npart</em>, <em>block_names</em>, <em>header</em>, <em>format2=True</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#GadgetWriteFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.GadgetWriteFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for write-only snapshots, as when we are creating a new set of files from, eg, a TipsySnap.
Should not be used directly. block_names is a list so we can specify an on-disc ordering.</p>
</dd></dl>

<dl class="class">
<dt id="pynbody.gadget.WriteBlock">
<em class="property">class </em><tt class="descclassname">pynbody.gadget.</tt><tt class="descname">WriteBlock</tt><big>(</big><em>partlen=4, dtype=&lt;type 'numpy.float32'&gt;, types=array([False, False, False, False, False, False], dtype=bool), name='    '</em><big>)</big><a class="reference internal" href="_modules/pynbody/gadget.html#WriteBlock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.gadget.WriteBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Internal structure for passing data around between file and snapshot</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.gadgethdf"></span><div class="section" id="gadgethdf">
<h4>gadgethdf<a class="headerlink" href="#gadgethdf" title="Permalink to this headline">¶</a></h4>
<p>Implementation of backend reader for GadgetHDF files by Andrew Pontzen.</p>
<p>The gadget array names are mapped into pynbody array names according
to the mappings given by the config.ini section [gadgethdf-name-mapping].</p>
<p>The gadget particle groups are mapped into pynbody families according
to the mappings specified by the config.ini section [gadgethdf-type-mapping].
This can be many-to-one (many gadget particle types mapping into one
pynbody family), but only datasets which are common to all gadget types
will be available from pynbody.</p>
<p>Currently spanned files are not supported (i.e. only the contents of
one file will be loaded).</p>
</div>
<span class="target" id="module-pynbody.halo"></span><div class="section" id="halo">
<h4>halo<a class="headerlink" href="#halo" title="Permalink to this headline">¶</a></h4>
<p>Implements halo catalogue functions. If you have a supported halo
catalogue on disk or a halo finder installed and correctly configured,
you can access a halo catalogue through f.halos() where f is a
SimSnap.  
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/HaloCatalogue">http://code.google.com/p/pynbody/wiki/HaloCatalogue</a>&gt;</p>
</div>
<span class="target" id="module-pynbody.kdtree"></span><div class="section" id="kdtree">
<h4>KDTree<a class="headerlink" href="#kdtree" title="Permalink to this headline">¶</a></h4>
<p>Provides access to nearest neighbour lists and smoothing lengths.</p>
</div>
<span class="target" id="module-pynbody.snapshot"></span><div class="section" id="snapshot">
<h4>snapshot<a class="headerlink" href="#snapshot" title="Permalink to this headline">¶</a></h4>
<p>Implements the basic SimSnap class and also SubSnap classes which can
represent different views of the same data.
&lt;<a class="reference external" href="http://code.google.com/p/pynbody/wiki/FiltersAndSubsims">http://code.google.com/p/pynbody/wiki/FiltersAndSubsims</a>&gt; You rarely
need to access this module directly.</p>
<dl class="class">
<dt id="pynbody.snapshot.FamilySubSnap">
<em class="property">class </em><tt class="descclassname">pynbody.snapshot.</tt><tt class="descname">FamilySubSnap</tt><big>(</big><em>base</em>, <em>fam</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#FamilySubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.FamilySubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a one-family portion of a parent snap object</p>
</dd></dl>

<dl class="class">
<dt id="pynbody.snapshot.IndexedSubSnap">
<em class="property">class </em><tt class="descclassname">pynbody.snapshot.</tt><tt class="descname">IndexedSubSnap</tt><big>(</big><em>base</em>, <em>index_array</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#IndexedSubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.IndexedSubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a subset of the simulation particles according
to an index array.</p>
</dd></dl>

<dl class="class">
<dt id="pynbody.snapshot.SimSnap">
<em class="property">class </em><tt class="descclassname">pynbody.snapshot.</tt><tt class="descname">SimSnap</tt><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>The basic holder of data for a single simulation snapshot.</p>
<p>Should be initialized indirectly using pynbody.load.</p>
<p>N.B. SimSnap is not thread-safe (when the derived-array system is
invoked).</p>
<dl class="method">
<dt id="pynbody.snapshot.SimSnap.all_keys">
<tt class="descname">all_keys</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.all_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.all_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of all arrays that can be either lazy-evaluated
or lazy loaded from an auxiliary file.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.assert_consistent">
<tt class="descname">assert_consistent</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.assert_consistent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.assert_consistent" title="Permalink to this definition">¶</a></dt>
<dd><p>Consistency checks, currently just checks that the length of all
stored arrays is consistent.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.derivable_keys">
<tt class="descname">derivable_keys</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.derivable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.derivable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-evaluated.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.families">
<tt class="descname">families</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.families"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.families" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the particle families which have representitives in this SimSnap.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.family_keys">
<tt class="descname">family_keys</tt><big>(</big><em>fam=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.family_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.family_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of arrays which are not accessible from this
view, but can be accessed from family-specific sub-views.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.get">
<tt class="descname">get</tt><big>(</big><em>key</em>, <em>alternative=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard python get method, returns self[key] if
key in self else alternative</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.halos">
<tt class="descname">halos</tt><big>(</big><em>*args</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.halos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.halos" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to instantiate a halo catalogue object for the given
snapshot, using the first available method.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.has_family_key">
<tt class="descname">has_family_key</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.has_family_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.has_family_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array name is accessible (in memory) for at least one family</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.has_key">
<tt class="descname">has_key</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.has_key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.has_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array name is accessible (in memory)</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.intersect">
<tt class="descname">intersect</tt><big>(</big><em>other</em>, <em>op=&lt;function intersect1d at 0x3427aa0&gt;</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.intersect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.intersect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set intersection of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.is_ancestor">
<tt class="descname">is_ancestor</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.is_ancestor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_ancestor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if other is a subview of self</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.is_derived_array">
<tt class="descname">is_derived_array</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.is_derived_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_derived_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the array or family array of given name is
auto-derived (and therefore read-only).</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.is_descendant">
<tt class="descname">is_descendant</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.is_descendant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.is_descendant" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if self is a subview of other</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.items">
<tt class="descname">items</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.items"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.items" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of tuples describing the array
names and their contents in memory</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directly accessible array names (in memory)</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.loadable_keys">
<tt class="descname">loadable_keys</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.loadable_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.loadable_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of arrays which can be lazy-loaded from 
an auxiliary file.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.mean_by_mass">
<tt class="descname">mean_by_mass</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.mean_by_mass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.mean_by_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the mean by mass of the specified array</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.original_units">
<tt class="descname">original_units</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.original_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.original_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all array&#8217;s units to be consistent with the units of
the original file.</p>
<p>If verbose is True, the conversions are printed.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.physical_units">
<tt class="descname">physical_units</tt><big>(</big><em>distance='kpc'</em>, <em>velocity='km s^-1'</em>, <em>mass='Msol'</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.physical_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.physical_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all array&#8217;s units to be consistent with the
distance, velocity, mass basis units specified.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.rotate_x">
<tt class="descname">rotate_x</tt><big>(</big><em>angle</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.rotate_x"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current x-axis by &#8216;angle&#8217; degrees.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.rotate_y">
<tt class="descname">rotate_y</tt><big>(</big><em>angle</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.rotate_y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current y-axis by &#8216;angle&#8217; degrees.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.rotate_z">
<tt class="descname">rotate_z</tt><big>(</big><em>angle</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.rotate_z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.rotate_z" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotates the snapshot about the current z-axis by &#8216;angle&#8217; degrees.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.setdiff">
<tt class="descname">setdiff</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.setdiff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.setdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set difference of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.transform">
<tt class="descname">transform</tt><big>(</big><em>matrix</em>, <em>ortho_tol=1e-08</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the snapshot according to the 3x3 matrix given.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.union">
<tt class="descname">union</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set union of this simulation view with another view
of the same simulation</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.unlink_array">
<tt class="descname">unlink_array</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.unlink_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.unlink_array" title="Permalink to this definition">¶</a></dt>
<dd><p>If the named array is auto-derived, this destroys the link so that
the array becomes editable but no longer auto-updates.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of the actual arrays in memory</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.snapshot.SimSnap.wrap">
<tt class="descname">wrap</tt><big>(</big><em>boxsize=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SimSnap.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SimSnap.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps the positions of the particles in the box to lie between
[-boxsize/2, boxsize/2].</p>
<p>If no boxsize is specified, self.properties[&#8220;boxsize&#8221;] is used.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pynbody.snapshot.SubSnap">
<em class="property">class </em><tt class="descclassname">pynbody.snapshot.</tt><tt class="descname">SubSnap</tt><big>(</big><em>base</em>, <em>_slice</em><big>)</big><a class="reference internal" href="_modules/pynbody/snapshot.html#SubSnap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.snapshot.SubSnap" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent a sub-view of a SimSnap, initialized by specifying a
slice.  Arrays accessed through __getitem__ are automatically
sub-viewed using the given slice.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.sph"></span><div class="section" id="sph">
<h4>sph<a class="headerlink" href="#sph" title="Permalink to this headline">¶</a></h4>
<p>pynbody SPH rendering module.</p>
<p>This module encompasses Kernel objects, which return C fragments from which
a final C code to perform the rendering is derived.</p>
<p>For most users, the function of interest will be render_image.</p>
<dl class="function">
<dt id="pynbody.sph.render_image">
<tt class="descclassname">pynbody.sph.</tt><tt class="descname">render_image</tt><big>(</big><em>snap</em>, <em>qty='rho'</em>, <em>x2=100</em>, <em>nx=500</em>, <em>y2=None</em>, <em>ny=None</em>, <em>x1=None</em>, <em>y1=None</em>, <em>z_plane=0.0</em>, <em>out_units=None</em>, <em>xy_units=None</em>, <em>kernel=&lt;pynbody.sph.Kernel object at 0x3befa10&gt;</em>, <em>z_camera=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/sph.html#render_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.render_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Render an SPH image using a typical (mass/rho)-weighted &#8216;scatter&#8217;
scheme.</p>
<p>Keyword arguments:
qty &#8211; The name of the array within the simulation to render
x2 &#8211; The x-coordinate of the right edge of the image (default 100.0)
nx &#8211; The number of pixels wide to make the image (default 500)
y2 &#8211; The y-coordinate of the upper edge of the image (default x2, or if ny is specified, x2*ny/nx)
ny &#8211; The number of pixels tall to make the image (default nx)
x1 &#8211; The x-coordinate of the left edge of the image (default -x2)
y1 &#8211; The y-coordinate of the lower edge of the image (default -y2)
z_plane &#8211; The z-coordinate of the plane of the image (default 0.0)
out_units &#8211; The units to convert the output image into (default no conversion)
xy_units &#8211; The units for the x and y axes
kernel &#8211; The Kernel object to use (default Kernel(), a 3D spline kernel)
z_camera &#8211; If this is set, a perspective image is rendered, assuming the kernel</p>
<blockquote>
<div>is suitable (i.e. is a projecting kernel). The camera is at the
specified z coordinate looking towards -ve z, and each pixel represents
a line-of-sight radially outwards from the camera. The width then specifies
the width of the image in the z=0 plane. Particles too close to the camera
are also excluded.</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pynbody.sph.render_spherical_image">
<tt class="descclassname">pynbody.sph.</tt><tt class="descname">render_spherical_image</tt><big>(</big><em>snap</em>, <em>qty='rho'</em>, <em>nside=8</em>, <em>distance=10.0</em>, <em>kernel=&lt;pynbody.sph.Kernel object at 0x3bef990&gt;</em>, <em>kstep=0.5</em>, <em>out_units=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/sph.html#render_spherical_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.sph.render_spherical_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Render an SPH image on a spherical surface. Note this is written in pure python and
could be optimized into C, but would then need linking with the healpix libraries.
Also currently uses a top-hat 3D kernel only.</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.tipsy"></span><div class="section" id="tipsy">
<h4>tipsy<a class="headerlink" href="#tipsy" title="Permalink to this headline">¶</a></h4>
<p>Implements classes and functions for handling tipsy files.  You rarely
need to access this module directly as it will be invoked
automatically via pynbody.load.</p>
<dl class="function">
<dt id="pynbody.tipsy.HII">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">HII</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#HII"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.HII" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of HII ions per proton mass</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.HeIII">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">HeIII</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#HeIII"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.HeIII" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of HeIII ions per proton mass</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.c_s">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">c_s</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#c_s"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.c_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Ideal gas sound speed</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.c_s_turb">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">c_s_turb</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#c_s_turb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.c_s_turb" title="Permalink to this definition">¶</a></dt>
<dd><p>Turbulent sound speed (from Mac Low &amp; Klessen 2004)</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.ljeans">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">ljeans</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#ljeans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.ljeans" title="Permalink to this definition">¶</a></dt>
<dd><p>Jeans length</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.ljeans_turb">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">ljeans_turb</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#ljeans_turb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.ljeans_turb" title="Permalink to this definition">¶</a></dt>
<dd><p>Jeans length</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.mjeans">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">mjeans</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#mjeans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.mjeans" title="Permalink to this definition">¶</a></dt>
<dd><p>Classical Jeans mass</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.mjeans_turb">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">mjeans_turb</tt><big>(</big><em>self</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#mjeans_turb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.mjeans_turb" title="Permalink to this definition">¶</a></dt>
<dd><p>Turbulent Jeans mass</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.mu">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">mu</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#mu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.mu" title="Permalink to this definition">¶</a></dt>
<dd><p>Relative atomic mass, i.e. number of particles per
proton mass, ignoring metals (since we generally only know the
mass fraction of metals, not their specific atomic numbers)</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.ne">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">ne</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#ne"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of electrons per proton mass</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.p">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">p</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.p" title="Permalink to this definition">¶</a></dt>
<dd><p>Pressure</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.tipsy.u">
<tt class="descclassname">pynbody.tipsy.</tt><tt class="descname">u</tt><big>(</big><em>sim</em><big>)</big><a class="reference internal" href="_modules/pynbody/tipsy.html#u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.tipsy.u" title="Permalink to this definition">¶</a></dt>
<dd><p>Specific Internal energy</p>
</dd></dl>

</div>
<span class="target" id="module-pynbody.units"></span><div class="section" id="units">
<h4>units<a class="headerlink" href="#units" title="Permalink to this headline">¶</a></h4>
<p>pynbody light-weight units module. A simple set of classes for tracking units.</p>
<div class="section" id="making-units">
<h5>Making units<a class="headerlink" href="#making-units" title="Permalink to this headline">¶</a></h5>
<p>You can make units in two ways. Either you can create a string, and
instantiate a Unit like this:</p>
<blockquote>
<div>units.Unit(&#8220;Msol kpc**-3&#8221;)
units.Unit(&#8220;2.1e12 m_p cm**-2/3&#8221;)</div></blockquote>
<p>Or you can do it within python, using the predefined Unit objects</p>
<blockquote>
<div>units.Msol * units.kpc**-3
2.1e12 * units.m_p * units.cm**(-2,3)</div></blockquote>
<p>In the last example, either a tuple describing a fraction or a
Fraction instance (from the standard python module fractions) is
acceptable.</p>
</div>
<div class="section" id="getting-conversion-ratios">
<h5>Getting conversion ratios<a class="headerlink" href="#getting-conversion-ratios" title="Permalink to this headline">¶</a></h5>
<p>To convert one unit to another, use the <tt class="docutils literal"><span class="pre">ratio</span></tt> member function:</p>
<blockquote>
<div>units.Msol.ratio(units.kg)  # -&gt;  1.99e30
(units.Msol / units.kpc**3).ratio(units.m_p/units.cm**3) # -&gt; 4.04e-8</div></blockquote>
<p>If the units cannot be converted, a UnitsException is raised:</p>
<blockquote>
<div>units.Msol.ratio(units.kpc)  # -&gt;UnitsException</div></blockquote>
</div>
<div class="section" id="specifying-numerical-values">
<h5>Specifying numerical values<a class="headerlink" href="#specifying-numerical-values" title="Permalink to this headline">¶</a></h5>
<p>Sometimes it&#8217;s necessary to specify a numerical value in the course
of a conversion. For instance, consider a comoving distance; this
can be specified in pynbody units as follows:</p>
<blockquote>
<div>comoving_kpc = units.kpc * units.a</div></blockquote>
<p>where units.a represents the scalefactor. We can attempt to convert
this to a physical distance as follows</p>
<blockquote>
<div>comoving_kpc.ratio(units.kpc)</div></blockquote>
<p>but this fails, throwing a UnitsException. On the other hand we
can specify a value for the scalefactor when we request the conversion</p>
<blockquote>
<div>comoving_kpc.ratio(units.kpc, a=0.5)  # -&gt; 0.5</div></blockquote>
<p>and the conversion completes with the expected result. The units
module also defines units.h for the dimensionless hubble constant,
which can be used similarly. <em>By default, all conversions happening
within a specific simulation context should pass in values for
a and h as a matter of routine.</em></p>
<p>Any IrreducibleUnit (see below) can have a value specified in this way,
but a and h are envisaged to be the most useful applications.</p>
</div>
<div class="section" id="defining-new-base-units">
<h5>Defining new base units<a class="headerlink" href="#defining-new-base-units" title="Permalink to this headline">¶</a></h5>
<p>The units module is fully extensible: you can define and name your own
units which then integrate with all the standard functions.</p>
<blockquote>
<div>litre = units.NamedUnit(&#8220;litre&#8221;,0.001*units.m**3)
gallon = units.NamedUnit(&#8220;gallon&#8221;,0.004546*units.m**3)
gallon.ratio(litre) # 4.546
(units.pc**3).ratio(litre) # 2.94e52</div></blockquote>
<p>You can even define completely new dimensions.</p>
<blockquote>
<div><p>V = units.IrreducibleUnit(&#8220;V&#8221;) # define a volt
C = units.NamedUnit(&#8220;C&#8221;, units.J/V) # define a coulomb
q = units.NamedUnit(&#8220;q&#8221;, 1.60217646e-19*C) # elementary charge
F = units.NamedUnit(&#8220;F&#8221;, C/V) # Farad
epsilon0 = 8.85418e-12 <a href="#id1"><span class="problematic" id="id2">*</span></a>F/units.m</p>
<p>(q*V).ratio(&#8220;eV&#8221;) # -&gt; 1.000...
((q**2)/(4*math.pi*epsilon0*units.m**2)).ratio(&#8220;N&#8221;) # -&gt; 2.31e-28</p>
</div></blockquote>
<dl class="function">
<dt id="pynbody.units.Unit">
<tt class="descclassname">pynbody.units.</tt><tt class="descname">Unit</tt><big>(</big><em>s</em><big>)</big><a class="reference internal" href="_modules/pynbody/units.html#Unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Class factory for units. Given a string s, creates
a Unit object.</p>
<dl class="docutils">
<dt>The string format is:</dt>
<dd>[&lt;scale&gt;] [&lt;unit_name&gt;][<a href="#id3"><span class="problematic" id="id4">**</span></a>&lt;rational_power&gt;] [[&lt;unit_name&gt;] ... ]</dd>
<dt>for example:</dt>
<dd>&#8220;1.e30 kg&#8221;
&#8220;kpc**2&#8221;
&#8220;26.2 m s**-1&#8221;</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pynbody.units.UnitBase">
<em class="property">class </em><tt class="descclassname">pynbody.units.</tt><tt class="descname">UnitBase</tt><a class="reference internal" href="_modules/pynbody/units.html#UnitBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for units</p>
<dl class="method">
<dt id="pynbody.units.UnitBase.in_units">
<tt class="descname">in_units</tt><big>(</big><em>*a</em>, <em>**kw</em><big>)</big><a class="reference internal" href="_modules/pynbody/units.html#UnitBase.in_units"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.in_units" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for ratio</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.units.UnitBase.irrep">
<tt class="descname">irrep</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/pynbody/units.html#UnitBase.irrep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.irrep" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a unit equivalent to this one (may be identical) but
expressed in terms of the currently defined IrreducibleUnit
instances.</p>
</dd></dl>

<dl class="method">
<dt id="pynbody.units.UnitBase.ratio">
<tt class="descname">ratio</tt><big>(</big><em>other</em>, <em>**substitutions</em><big>)</big><a class="reference internal" href="_modules/pynbody/units.html#UnitBase.ratio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.units.UnitBase.ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the conversion ratio between this Unit and another
specified unit</p>
</dd></dl>

</dd></dl>

</div>
</div>
<span class="target" id="module-pynbody.util"></span><div class="section" id="util">
<h4>util<a class="headerlink" href="#util" title="Permalink to this headline">¶</a></h4>
<p>Various utility routines used internally by pynbody.</p>
<dl class="exception">
<dt id="pynbody.util.LazyKeyError">
<em class="property">exception </em><tt class="descclassname">pynbody.util.</tt><tt class="descname">LazyKeyError</tt><big>(</big><em>name</em>, <em>bases=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#LazyKeyError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.LazyKeyError" title="Permalink to this definition">¶</a></dt>
<dd><p>An extended exception, like KeyError, but allowing information
about the ways in which the framework attempted to generate the
array to be queried. <em>This is not currently in use within the
pynbody framework, and is kept here as part of a previous
attempt to clean up derived/lazy array backtraces</em>.</p>
<p>Usage:</p>
<dl class="docutils">
<dt>try :</dt>
<dd>do_something()</dd>
<dt>catch LazyKeyError, error_from_level_below:</dt>
<dd>raise LazyKeyError(&#8220;name of current array&#8221;, error_from_level_below)</dd>
</dl>
<p>To find out what actually happened without looking at the text, you can
inspect self.bases, a list of array names which were accessed.
This is just a list of array names.</p>
</dd></dl>

<dl class="class">
<dt id="pynbody.util.Registry">
<em class="property">class </em><tt class="descclassname">pynbody.util.</tt><tt class="descname">Registry</tt><a class="reference internal" href="_modules/pynbody/util.html#Registry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.Registry" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple extension of the dict class to make the
__repr__ more readable.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.arrays_are_same">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">arrays_are_same</tt><big>(</big><em>a1</em>, <em>a2</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#arrays_are_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.arrays_are_same" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if a1 and a2 are numpy views pointing to the exact
same underlying data; False otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.bisect">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">bisect</tt><big>(</big><em>left</em>, <em>right</em>, <em>f</em>, <em>epsilon=None</em>, <em>eta=0</em>, <em>verbose=False</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#bisect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the value x such that f(x)=0 for a monotonically
increasing function f, using a binary search.</p>
<p>The search stops when either the bounding domain is
smaller than epsilon (by default 10^-7 times the original
region) OR a value f(x) is found such that <a href="#id5"><span class="problematic" id="id6">|</span></a>f(x)|&lt;eta (by default
eta=0, so this criterion is never satisfied).</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.chained_slice">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">chained_slice</tt><big>(</big><em>s1</em>, <em>s2</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#chained_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.chained_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a slice s3 with the property that
ar[s1][s2] == ar[s3]</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.concatenate_indexing">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">concatenate_indexing</tt><big>(</big><em>i1</em>, <em>i2</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#concatenate_indexing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.concatenate_indexing" title="Permalink to this definition">¶</a></dt>
<dd><p>Given either a numpy array or slice for both i1 and i2,
return either a numpy array or slice i3 with the property that</p>
<p>ar[i3] == ar[i1][i2].</p>
<p>As a convenience, if i2 is None, i1 is returned</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.cutgz">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">cutgz</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#cutgz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.cutgz" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip the .gz ending off a string</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.equipartition">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">equipartition</tt><big>(</big><em>ar</em>, <em>nbins</em>, <em>min=None</em>, <em>max=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#equipartition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.equipartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an array ar, return nbins+1 monotonically increasing bin edges
such that the number of items in each bin is approximately equal</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.gauss_jordan">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">gauss_jordan</tt><big>(</big><em>out</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#gauss_jordan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.gauss_jordan" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple Gauss-Jordan matrix inverter. This is provided so that
matrices of fractions can be inverted (numpy linalg converts
everything to floats first.)</p>
<p>Don&#8217;t use on large matrices &#8211; it&#8217;s slow!</p>
<p>Based on public domain code by Jarno Elonen.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.index_before_slice">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">index_before_slice</tt><big>(</big><em>s</em>, <em>index</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#index_before_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.index_before_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an index array new_index with the property that, for a
slice s (start, stop and step all positive), ar[s][index] ==
ar[new_index].</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.index_of_first">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">index_of_first</tt><big>(</big><em>array</em>, <em>find</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#index_of_first"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.index_of_first" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element in array
which satisfies array[index]&gt;=find. The array must
be sorted in ascending order.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.intersect_slices">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">intersect_slices</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>array_length=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#intersect_slices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.intersect_slices" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two python slices s1 and s2, return a new slice which
will extract the data of an array d which is in both d[s1] and
d[s2].</p>
<p>Note that it may not be possible to do this without information on
the length of the array referred to, hence all slices with
end-relative indexes are first converted into begin-relative
indexes. This means that the slice returned may be specific to
the length specified.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.open_">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">open_</tt><big>(</big><em>filename</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#open_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.open_" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file, determining from the filename whether to use
gzip decompression</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.open_with_size">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">open_with_size</tt><big>(</big><em>filename</em>, <em>*args</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#open_with_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.open_with_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file for reading, returning also the (decompressed)
file size</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.rational_matrix_inv">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">rational_matrix_inv</tt><big>(</big><em>matrix</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#rational_matrix_inv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.rational_matrix_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple replacement for numpy linalg matrix inverse
which handles fractions exactly. Not suitable for large
matrices!</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.relative_slice">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">relative_slice</tt><big>(</big><em>s_relative_to</em>, <em>s</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#relative_slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.relative_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a slice s, return a slice s_prime with the property that
array[s_relative_to][s_prime] == array[s]. Clearly this will
not be possible for arbitrarily chosen s_relative_to and s, but
it should be possible for s=intersect_slices(s_relative_to, s_any)
which is the use case envisioned here (and used by SubSim).
This code currently does not work with end-relative (i.e. negative)
start or stop positions.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.util.set_array_if_not_same">
<tt class="descclassname">pynbody.util.</tt><tt class="descname">set_array_if_not_same</tt><big>(</big><em>a_store</em>, <em>a_in</em>, <em>index=None</em><big>)</big><a class="reference internal" href="_modules/pynbody/util.html#set_array_if_not_same"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.util.set_array_if_not_same" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine checks whether a_store and a_in ultimately point to the
same buffer; if not, the contents of a_in are copied into a_store.</p>
</dd></dl>

</div>
<dl class="function">
<dt id="pynbody.load">
<tt class="descclassname">pynbody.</tt><tt class="descname">load</tt><big>(</big><em>filename</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/pynbody.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pynbody.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a file using the appropriate class, returning a SimSnap
instance.</p>
</dd></dl>

<dl class="function">
<dt id="pynbody.new">
<tt class="descclassname">pynbody.</tt><tt class="descname">new</tt><big>(</big><em>n_particles=0</em>, <em>**families</em><big>)</big><a class="headerlink" href="#pynbody.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a blank SimSnap, with the specified number of particles.</p>
<p>Position, velocity and mass arrays are created and filled
with zeros.</p>
<p>By default all particles are taken to be dark matter.
To specify otherwise, pass in keyword arguments specifying
the number of particles for each family, e.g.</p>
<p>f = new(dm=50, star=25, gas=25)</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to pynbody&#8217;s documentation!</a><ul>
<li><a class="reference internal" href="#pynbody">pynbody</a><ul>
<li><a class="reference internal" href="#getting-help">Getting help</a></li>
<li><a class="reference internal" href="#what-s-available">What&#8217;s available</a></li>
<li><a class="reference internal" href="#configuration">Configuration</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
<li><a class="reference internal" href="#array">array</a><ul>
<li><a class="reference internal" href="#getting-the-array-in-specified-units">Getting the array in specified units</a></li>
<li><a class="reference internal" href="#specifying-rules-for-ufunc-s">Specifying rules for ufunc&#8217;s</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bridge">bridge</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic usage</a></li>
<li><a class="reference internal" href="#identifying-halos-between-different-outputs">Identifying halos between different outputs</a></li>
<li><a class="reference internal" href="#which-class-to-use">Which class to use</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derived">derived</a></li>
<li><a class="reference internal" href="#family">family</a></li>
<li><a class="reference internal" href="#filt">filt</a></li>
<li><a class="reference internal" href="#gadget">gadget</a></li>
<li><a class="reference internal" href="#gadgethdf">gadgethdf</a></li>
<li><a class="reference internal" href="#halo">halo</a></li>
<li><a class="reference internal" href="#kdtree">KDTree</a></li>
<li><a class="reference internal" href="#snapshot">snapshot</a></li>
<li><a class="reference internal" href="#sph">sph</a></li>
<li><a class="reference internal" href="#tipsy">tipsy</a></li>
<li><a class="reference internal" href="#units">units</a><ul>
<li><a class="reference internal" href="#making-units">Making units</a></li>
<li><a class="reference internal" href="#getting-conversion-ratios">Getting conversion ratios</a></li>
<li><a class="reference internal" href="#specifying-numerical-values">Specifying numerical values</a></li>
<li><a class="reference internal" href="#defining-new-base-units">Defining new base units</a></li>
</ul>
</li>
<li><a class="reference internal" href="#util">util</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pynbody v0.13-alpha documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Andrew Pontzen, Rok Roskar, Greg Stinson, Tom Quinn, Rory Woods, Jonathan Coles, Simeon Bird, Jo Bovy, Darren Reed.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.8.
    </div>
  </body>
</html>